
// ${AUTO_WARNING}
// ${Program}

${{Only:Muon:
#include "TRandom3.h"
}}
#include "../include/${Object}.h"

using namespace std;
using namespace DESY;

${{Only:Muon:
TRandom* Muon::sm_random = new TRandom3();
}}

${Object}::${Object}() {
  
}


${Object}::${Object}( const D3PD::${Object}D3PDObject* ana, const Int_t idx ) 
: Basic( idx )
${{Only:TruthJet,Jet,Muon,Electron: , Particle() }}

${{Only:Jet,TruthJet:
  , m_isTagged( false )
}}
{
  m_ana=ana;
  // copy variables defined in Particle.h
${{AllBasics:    m_#name# = &((*ana->#name#)[idx]); }}
  m_lvl    = ana->detailLevel;

${{Only:Muon:
  m_ptMC_value = *m_pt;
     //m_ptMS = 0;
     //m_ptID = 0;
}}

${{Only:Jet:
  m_scalefactor = 0;
}}
  // copy rest of variables
  /*${ {AllNoBools:    printf("acc#name#\n"); if (ana->m_connectsucceeded[#index#]) 
         {printf("?\n"); m_#name# = &((*ana->#name#)[idx]);}
    else {printf("fak\n"); m_#name# = new #type#(); *m_#name# = #default#; } }}
  */
${{AllVarsDL:ana->detailLevel:    if (ana->m_connectsucceeded[#index#]) m_#name# = &((*ana->#name#)[idx]); else m_#name# = #default#; }}

${{Only:Muon:
 //Set ptMS and ptID
 //if( (ana->detailLevel & D3PD::MuonAnalysis) == D3PD::MuonAnalysis ) {
 //   if(me_qoverp()!=0) m_ptMS = 1./std::fabs(me_qoverp()) * std::sin(me_theta()); else m_ptMS = 0; 
 //	  if(id_qoverp()!=0) m_ptID = 1./std::fabs(id_qoverp()) * std::sin(id_theta()); else m_ptID = 0; 
 //}

}}

${{Only:Electron:
	Set("clusterEuncorrected", cluster_e());
	Set("EtCone20uncorrected", etcone20());
}}

}


${Object}::~${Object}() {

}

${{Only:Muon:
void Muon::correctMCpt() {
  /*floatingnumber c1 = 0.991;
  floatingnumber c2 = ( this->eta() > 1.05 ) ? 0.06 : 0.03;
  floatingnumber oneoverpt = 1./( this->pt() );
  oneoverpt = ( 1. + c2*sm_random->Gaus() )/( c1*m_ptMC_value );
  *m_pt=1./oneoverpt;*/
  // smearings
  floatingnumber smearMS = smearingFunction(this->pt()/1000.,this->eta(),"MS");
  floatingnumber smearID = smearingFunction(this->pt()/1000.,this->eta(),"ID");
  //invoke combination smearings (ptCB will be in GeV as well)
  *m_pt = 1000.*combineMomentaSmear(smearMS,smearID,this->pt()/1000.,this->eta());
}


/**                            pt in GeV                 "MS","ID" **/
double Muon::smearingFunction(double pt,double eta,std::string DetType){

  bool UseTan2=true;
  
  //gRandom->SetSeed(0);
  
  double ID_MS[]={0,0,0,0};
  double ID_AL[]={0.000403,0.000913,0.001273,0.002667};
  double ID_ALTAN[]={0,0,0,0.0001344};
  double MS_MS[]={0.02619,0.067,0.0377,0.0407};
  double MS_AL[]={0.00018,0.00018,0.00018,0.0005};
  
  
  /** smearing factor pt_new=pt_old*smear **/
  double smear=1;
  
  int detRegion=-1;
  if (fabs(eta)<1.05)     detRegion=0;
  else if (fabs(eta)<1.7) detRegion=1;
  else if (fabs(eta)<2.0) detRegion=2;
  else if (fabs(eta)<2.5) detRegion=3;
  else return 1.0;
  
  double g1 = gRandom->Gaus(0,1);  
  double g2 = gRandom->Gaus(0,1);  
  if (DetType=="MS") {
    smear = (1+MS_MS[detRegion]*g1+MS_AL[detRegion]*g2*pt);
} else if (DetType=="ID") {
    if (UseTan2&&detRegion==3) {
      smear = (1+ID_MS[detRegion]*g1+ID_ALTAN[detRegion]*g2*pt*sinh(eta)*sinh(eta));
} else {
      smear = (1+ID_MS[detRegion]*g1+ID_AL[detRegion]*g2*pt);
}	 
}
  
  return smear;
}


/**  pT in GeV    **/
double Muon::combineMomentaSmear(double smearMS,double smearID,double pt, double eta){

  /** set to true if you want to use the pt/tan(theta)^2 parametrization for ID in CSC region **/
  bool UseTan2=true;
  
  double ptCB=pt;    
  
  double MC_ID_MS[]    = {0.016,0.026,0.034,0.048};
  double MC_ID_AL[]    = {0.00029,0.0003,0.00042,0.00094};
  double MC_ID_ALTAN[] = {0,0,0,0.000063};
  double MC_MS_CALO[]  = {0.23,0,0,0.17};
  double MC_MS_MS[]    = {0.027,0.054,0.033,0.027};
  double MC_MS_AL[]    = {0.00013,0.00023,0.000093,0.000074};
  
  int detRegion=-1;
  if (fabs(eta)<1.05)     detRegion=0;
  else if (fabs(eta)<1.7) detRegion=1;
  else if (fabs(eta)<2.0) detRegion=2;
  else if (fabs(eta)<2.5) detRegion=3;
  else return ptCB;
  
  /** do the average with the EXPECTED resolutions **/
  
  double sigmaMS=pt*pow(
			pow(MC_MS_CALO[detRegion]/pt,2)+
			pow(MC_MS_MS[detRegion],2)+
			pow(MC_MS_AL[detRegion]*pt,2),0.5);
  
  double sigmaID=pt*pow(
			pow(MC_ID_MS[detRegion],2)+
			pow(MC_ID_AL[detRegion]*pt,2),0.5);
  
  if (detRegion==3&&UseTan2) {
    sigmaID=pt*pow(
		pow(MC_ID_MS[detRegion],2)+
		pow(MC_ID_ALTAN[detRegion]*pt*sinh(eta)*sinh(eta),2),0.5);
}
  
  
  double invSmsQ=1./sigmaMS/sigmaMS;
  double invSidQ=1./sigmaID/sigmaID;
  ptCB=pt*(1+((smearMS-1)*invSmsQ+(smearID-1)*invSidQ)/(invSmsQ+invSidQ));
  
  return ptCB;
  
}


}}

ostream& operator<<( ostream& out,
                     const ${Object}& rhs ) {
  
   out << "${Object} -" << ( Basic) rhs; 
${{Only:Jet,Muon,Electron,TruthJet:   out << "${Object} -" << ( Particle ) rhs; }}
${{Only:Jet,TruthJet:
  out << " isTagged:" << rhs.isTagged();
}}
${{Only:Jet:
  out << " JES: " << rhs.getJetSF();
}}
  ${{PrintAllVarsDL:rhs.getLvl():  out << " #name# " << rhs.#name#()}}
  return out;
}

${{Only:Electron:
floatingnumber ${Object}::DeltaRcluster(const Particle* p) const {
  Double_t deta = *(m_cluster_eta) - p->eta();
  Double_t dphi = *(m_cluster_phi) - p->phi();
  double pi = TMath::Pi();
  double twopi = 2*pi;
  while (dphi >= pi) dphi -= twopi;
  while (dphi < -pi) dphi += twopi;
  return sqrt( deta*deta+dphi*dphi );
}


floatingnumber ${Object}::DeltaRtrack(const Particle* p) const {
  Double_t deta = *(m_track_eta) - p->eta();
  Double_t dphi = *(m_track_phi) - p->phi();
  double pi = TMath::Pi();
  double twopi = 2*pi;
  while (dphi >= pi) dphi -= twopi;
  while (dphi < -pi) dphi += twopi;
  return sqrt( deta*deta+dphi*dphi );
}

}}

${{Only:Muon,Electron:
bool sort${Object}Pt::operator()( const ${Object}& e1,
                                 const ${Object}& e2 ) {
  return ( e1.pt() > e2.pt() ) ? true : false;
}

bool operator<<( const ${Object}& e1, const ${Object}& e2 ) {
  sort${Object}Pt sort;
  return sort( e1, e2 );
}
}}

${{Only:Muon,Jet,TruthJet:

TLorentzVector* ${Object}::getTLV() const {

  TLorentzVector* tlv = new TLorentzVector();
  tlv->SetPtEtaPhiE(*(m_pt), *(m_eta), *(m_phi), *(m_e));
  return tlv;

}


TLorentzVector ${Object}::tlv() const {

  TLorentzVector tlv;
  tlv.SetPtEtaPhiE(*(m_pt), *(m_eta), *(m_phi), *(m_e));
  return tlv;

}
}}

${{Only:TruthParticle:

TLorentzVector ${Object}::tlv() const {
  TLorentzVector tlv;
  tlv.SetPtEtaPhiM(*(m_pt), *(m_eta), *(m_phi), *(m_m));
  return tlv;
}

}}

${{Only:Electron:
TLorentzVector* ${Object}::getEgammaTLV() const {
  // function overloads Particle getTLV to reflect egamma CP recommendations
  TLorentzVector* tlv = new TLorentzVector();
  if ( (*(m_nPixelHits) + *(m_nSCTHits) ) >= 4 )
    tlv->SetPtEtaPhiE((*(m_cluster_e))/cosh(*(m_track_eta)), *(m_track_eta), *(m_track_phi), *(m_cluster_e));
  else 
    tlv->SetPtEtaPhiE((*(m_cluster_e))/cosh(*(m_cluster_eta)), *(m_cluster_eta), *(m_cluster_phi), *(m_cluster_e));
  return tlv;
}

TLorentzVector ${Object}::tlv() const {
  return tlv_egamma();
}

TLorentzVector ${Object}::tlv_egamma() const {
  // function overloads Particle getTLV to reflect egamma CP recommendations
  TLorentzVector tlv;
  if ( (*(m_nPixelHits) + *(m_nSCTHits) ) >= 4 )
    tlv.SetPtEtaPhiE((*(m_cluster_e))/cosh(*(m_track_eta)), *(m_track_eta), *(m_track_phi), *(m_cluster_e));
  else 
    tlv.SetPtEtaPhiE((*(m_cluster_e))/cosh(*(m_cluster_eta)), *(m_cluster_eta), *(m_cluster_phi), *(m_cluster_e));
  return tlv;
}




}}


${{Only:Muon:
TLorentzVector* ${Object}::getIDTLV() const {
  double p = fabs( 1/( *(m_id_qoverp) ) );
  double eta = -log( tan( (*(m_id_theta))/2 ) );
  double pt = p/cosh( fabs(eta) );
  TLorentzVector* tlv = new TLorentzVector();
  tlv->SetPtEtaPhiE( pt, eta, *(m_id_phi), sqrt(p*p + muMass*muMass) );
  return tlv;
}

TLorentzVector* ${Object}::getMETLV() const {
  double p = fabs( 1/( *(m_me_qoverp) ) );
  double eta = -log( tan( (*(m_me_theta))/2 ) );
  double pt = p/cosh( fabs(eta) );
  TLorentzVector* tlv = new TLorentzVector();
  tlv->SetPtEtaPhiE( pt, eta, *(m_me_phi), sqrt(p*p + muMass*muMass) );
  return tlv;
}

TLorentzVector* ${Object}::getMSTLV() const {
  double p = fabs( 1/( *(m_ms_qoverp) ) );
  double eta = -log( tan( (*(m_ms_theta))/2 ) );
  double pt = p/cosh( fabs(eta) );
  TLorentzVector* tlv = new TLorentzVector();
  tlv->SetPtEtaPhiE( pt, eta, *(m_ms_phi), sqrt(p*p + muMass*muMass) );
  return tlv;
}

TLorentzVector* ${Object}::getTrackTLV() const {
  double p = fabs( 1/( *(m_track_qoverp) ) );
  double eta = -log( tan( (*(m_track_theta))/2 ) );
  double pt = p/cosh( fabs(eta) );
  TLorentzVector* tlv = new TLorentzVector();
  tlv->SetPtEtaPhiE( pt, eta, *(m_track_phi), sqrt(p*p + muMass*muMass) );
  return tlv;
}
}}


${{Only:Jet:
void ${Object}::scaleJES( const floatingnumber ssigma ) {
  m_scalefactor = ssigma;
  if( fabs( ssigma ) < 1e-6 ) return;
 
  *(m_e)  *= ( 1.0 + ssigma );
  *(m_pt) *= ( 1.0 + ssigma );
 
//  if ( m_lvl >= 1 ) {
//    *(m_px) *= ( 1.0 + ssigma );
//    *(m_py) *= ( 1.0 + ssigma );
//    *(m_pz) *= ( 1.0 + ssigma );
//  }
}
}}

${{Only:TruthParticle:
  floatingnumber TruthParticle::DeltaR(const TruthParticle& p) const {
    return this->tlv().DeltaR(p.tlv());
  }
}}
